<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RFP Assistant</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 0;
        background: #0f172a;
        color: #e5e7eb;
      }
      main {
        max-width: 1200px;
        margin: 2rem auto 3rem;
        padding: 0 1.5rem;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.5rem;
        align-items: flex-start;
      }
      @media (max-width: 960px) {
        .layout {
          grid-template-columns: minmax(0, 1fr);
        }
      }
      h1 {
        font-size: 1.6rem;
        margin: 0;
      }
      .card {
        background: radial-gradient(circle at top left, #020617, #020617 40%, #020617);
        border-radius: 0.75rem;
        padding: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.15);
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.85);
        margin-bottom: 1.5rem;
      }
      .card h2 {
        margin-top: 0;
        font-size: 1.2rem;
      }
      .subheading {
        font-size: 0.9rem;
        color: #9ca3af;
        margin-bottom: 0.5rem;
      }
      .upload-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }
      input[type="file"] {
        color: #e5e7eb;
      }
      button {
        background: #2563eb;
        border: none;
        color: white;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        cursor: pointer;
        font-size: 0.95rem;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .status {
        margin-top: 0.75rem;
        font-size: 0.9rem;
        color: #9ca3af;
      }
      .columns {
        display: block;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        font-size: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.4));
        color: #e5e7eb;
      }
      pre {
        max-height: 260px;
        overflow: auto;
        padding: 0.75rem;
        background: radial-gradient(circle at top left, #020617, #020617 55%, #020617);
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        font-size: 0.8rem;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .agent-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .pill {
        font-size: 0.75rem;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        color: #e5e7eb;
        background: radial-gradient(circle at top left, #0b1220, #020617);
      }
      .pill-processing {
        border-color: #f59e0b;
        color: #fbbf24;
        animation: pulse 2s infinite;
      }
      .pill-complete {
        border-color: #16a34a;
        color: #bbf7d0;
      }
      .pill-error {
        border-color: #dc2626;
        color: #fca5a5;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }
      .agent-summary {
        font-size: 0.85rem;
        color: #6b7280;
        margin-bottom: 0.75rem;
        padding: 0.5rem;
        background: #020617;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      .agent-summary strong {
        color: #9ca3af;
      }
      .accept-row {
        margin-top: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
        color: #9ca3af;
      }
      .accept-row input {
        accent-color: #22c55e;
      }
      .tabs {
        display: flex;
        border-bottom: 1px solid #1f2937;
        margin-bottom: 1rem;
      }
      .tab-button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
        border: none;
        border-bottom: 2px solid transparent;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        transition: color 0.15s ease, border-color 0.15s ease, background 0.15s ease;
      }
      .tab-button.active {
        color: #e5e7eb;
        border-bottom-color: #2563eb;
      }
      .tab-button:not(.active):hover {
        background: #020617;
      }
      .tab-panel {
        display: none;
      }
      .tab-panel.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="layout" id="layout">
        <div>
          <section class="card">
            <div style="margin-bottom: 1rem;">
              <h2 style="margin: 0;">RFP Processing</h2>
              <div class="subheading" style="margin-top: 0.25rem;">
                Upload an RFP document and inspect each agent’s view of the text.
              </div>
            </div>
            <div class="upload-row">
              <input id="file-input" type="file" accept=".pdf,.doc,.docx" />
              <button id="upload-btn">Upload &amp; process</button>
            </div>
            <div id="status" class="status"></div>
          </section>

          <section class="card" id="agents-section" style="display: none">
            <div class="tabs">
              <button class="tab-button active" data-tab="ocr">1. OCR (Qwen)</button>
              <button class="tab-button" data-tab="extraction">2. Extraction agent</button>
              <button class="tab-button" data-tab="scope">3. Scope</button>
              <button class="tab-button" data-tab="requirements">4. Requirements</button>
            </div>

            <div class="columns">
          <div id="tab-ocr" class="tab-panel active">
            <div class="agent-header">
              <h2>1. Raw OCR Text</h2>
            </div>
            <div class="agent-summary">
              <strong>Description:</strong> Full text extracted from the original PDF/DOCX. Uses direct extraction (pdfplumber/python-docx) when possible, falls back to Qwen vision model for scanned/image-based documents.
            </div>
            <pre id="ocr-output">Waiting for OCR…</pre>
          </div>

          <div id="tab-extraction" class="tab-panel">
            <div class="agent-header">
              <h2>2. Extraction Agent</h2>
              <span id="extraction-pill" class="pill">meta-llama/Llama-3.2-1B</span>
            </div>
            <div class="agent-summary" id="extraction-summary">
              <strong>Status:</strong> <span id="extraction-status">Waiting...</span>
            </div>
            <div class="badge">Translated text + codes &amp; metadata</div>
            <pre id="extraction-output">Processing...</pre>
          </div>

          <div id="tab-scope" class="tab-panel">
            <div class="agent-header">
              <h2>3. Scope Agent</h2>
              <span id="scope-pill" class="pill">google/gemma-2-2b-it</span>
            </div>
            <div class="agent-summary" id="scope-summary">
              <strong>Status:</strong> <span id="scope-status">Waiting...</span>
            </div>
            <div class="badge">Essential text vs removed content</div>
            <pre id="scope-output">Waiting for extraction...</pre>
            <div class="accept-row">
              <input type="checkbox" id="accept-scope" />
              <label for="accept-scope">I accept this scoped text</label>
            </div>
          </div>

          <div id="tab-requirements" class="tab-panel">
            <div class="agent-header">
              <h2>4. Requirements Agent</h2>
              <span id="req-pill" class="pill">meta-llama/Llama-3.1-8B</span>
            </div>
            <div class="agent-summary" id="req-summary">
              <strong>Status:</strong> <span id="req-status">Waiting...</span>
            </div>
            <div class="badge">
              Solution vs response-structure requirements
            </div>
            <pre id="requirements-output">Accept scoped text to reveal…</pre>
          </div>
        </div>
          </section>
        </div>
      </div>
    </main>

    <script>
      const API_BASE = "http://127.0.0.1:8001";

      const fileInput = document.getElementById("file-input");
      const uploadBtn = document.getElementById("upload-btn");
      const statusEl = document.getElementById("status");
      const agentsSection = document.getElementById("agents-section");
      const extractionOutput = document.getElementById("extraction-output");
      const ocrOutput = document.getElementById("ocr-output");
      const scopeOutput = document.getElementById("scope-output");
      const requirementsOutput = document.getElementById(
        "requirements-output",
      );
      const acceptScope = document.getElementById("accept-scope");
      const reqPill = document.getElementById("req-pill");
      const extractionPill = document.getElementById("extraction-pill");
      const scopePill = document.getElementById("scope-pill");
      const extractionStatus = document.getElementById("extraction-status");
      const scopeStatus = document.getElementById("scope-status");
      const reqStatus = document.getElementById("req-status");
      const layout = document.getElementById("layout");

      let lastPipelineResult = null;

      function setStatus(text, isError = false) {
        statusEl.textContent = text;
        statusEl.style.color = isError ? "#f97373" : "#9ca3af";
      }

      function formatJson(obj) {
        try {
          return JSON.stringify(obj, null, 2);
        } catch (e) {
          return String(obj);
        }
      }

      function formatExtractionOutput(extraction) {
        if (!extraction) return "No extraction data available.";
        
        let output = "EXTRACTION RESULTS\n";
        output += "=".repeat(60) + "\n\n";
        
        output += "Language: " + (extraction.language || "Unknown") + "\n\n";
        
        if (extraction.cpv_codes && extraction.cpv_codes.length > 0) {
          output += "CPV Codes (" + extraction.cpv_codes.length + "):\n";
          extraction.cpv_codes.forEach((code, idx) => {
            output += "   " + (idx + 1) + ". " + code + "\n";
          });
          output += "\n";
        } else {
          output += "CPV Codes: None found\n\n";
        }
        
        if (extraction.other_codes && extraction.other_codes.length > 0) {
          output += "Other Codes (" + extraction.other_codes.length + "):\n";
          extraction.other_codes.forEach((code, idx) => {
            output += "   " + (idx + 1) + ". " + code + "\n";
          });
          output += "\n";
        } else {
          output += "Other Codes: None found\n\n";
        }
        
        if (extraction.key_requirements_summary) {
          output += "Key Requirements Summary:\n";
          output += "-".repeat(60) + "\n";
          output += extraction.key_requirements_summary + "\n\n";
        }
        
        if (extraction.raw_structured && Object.keys(extraction.raw_structured).length > 0) {
          output += "Additional Metadata:\n";
          output += "-".repeat(60) + "\n";
          for (const [key, value] of Object.entries(extraction.raw_structured)) {
            output += key + ": " + JSON.stringify(value) + "\n";
          }
        }
        
        return output;
      }

      function formatScopeOutput(scope) {
        if (!scope) return "No scope data available.";
        
        let output = "SCOPE ANALYSIS\n";
        output += "=".repeat(60) + "\n\n";
        
        if (scope.rationale) {
          output += "Rationale:\n";
          output += "-".repeat(60) + "\n";
          output += scope.rationale + "\n\n";
        }
        
        if (scope.removed_text && scope.removed_text.trim().length > 0) {
          output += "REMOVED TEXT (Out of Scope)\n";
          output += "-".repeat(60) + "\n";
          output += scope.removed_text + "\n\n";
        } else {
          output += "REMOVED TEXT: None\n\n";
        }
        
        if (scope.necessary_text && scope.necessary_text.trim().length > 0) {
          output += "NECESSARY TEXT (Extracted)\n";
          output += "-".repeat(60) + "\n";
          output += scope.necessary_text + "\n\n";
        } else {
          output += "NECESSARY TEXT: None\n\n";
        }
        
        if (scope.comparison_agreement !== undefined) {
          output += "COMPARISON VALIDATION\n";
          output += "-".repeat(60) + "\n";
          output += "Agreement: " + (scope.comparison_agreement ? "Yes" : "No") + "\n";
          if (scope.comparison_notes) {
            output += "Notes: " + scope.comparison_notes + "\n";
          }
          output += "\n";
        }
        
        output += "CLEANED TEXT (Same as Necessary Text)\n";
        output += "-".repeat(60) + "\n";
        if (scope.cleaned_text) {
          output += scope.cleaned_text + "\n\n";
        } else {
          output += "No cleaned text available.\n\n";
        }
        
        return output;
      }

      function formatRequirementsOutput(requirements) {
        if (!requirements) return "No requirements data available.";
        
        let output = "REQUIREMENTS ANALYSIS\n";
        output += "=".repeat(60) + "\n\n";
        
        if (requirements.solution_requirements && requirements.solution_requirements.length > 0) {
          output += "SOLUTION REQUIREMENTS (" + requirements.solution_requirements.length + ")\n";
          output += "=".repeat(60) + "\n\n";
          requirements.solution_requirements.forEach((req, idx) => {
            output += "[" + (idx + 1) + "] Type: " + req.type + "\n";
            output += "-".repeat(60) + "\n";
            output += req.source_text + "\n\n";
          });
        } else {
          output += "SOLUTION REQUIREMENTS: None found\n\n";
        }
        
        if (requirements.response_structure_requirements && requirements.response_structure_requirements.length > 0) {
          output += "RESPONSE STRUCTURE REQUIREMENTS (" + requirements.response_structure_requirements.length + ")\n";
          output += "=".repeat(60) + "\n\n";
          requirements.response_structure_requirements.forEach((req, idx) => {
            output += "[" + (idx + 1) + "] Type: " + req.type + "\n";
            output += "-".repeat(60) + "\n";
            output += req.source_text + "\n\n";
          });
        } else {
          output += "RESPONSE STRUCTURE REQUIREMENTS: None found\n\n";
        }
        
        return output;
      }

      function updateAgentStatus(agent, status, pill, statusText) {
        pill.className = "pill";
        if (status === "processing") {
          pill.classList.add("pill-processing");
          statusText.textContent = "Processing...";
        } else if (status === "complete") {
          pill.classList.add("pill-complete");
          statusText.textContent = "Complete";
        } else if (status === "error") {
          pill.classList.add("pill-error");
          statusText.textContent = "Error";
        } else {
          statusText.textContent = "Waiting...";
        }
      }

      function switchTab(tabName) {
        document.querySelectorAll(".tab-button").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.tab === tabName);
        });
        document.querySelectorAll(".tab-panel").forEach((panel) => {
          panel.classList.toggle(
            "active",
            panel.id === `tab-${tabName}`,
          );
        });
      }

      document.querySelectorAll(".tab-button").forEach((btn) => {
        btn.addEventListener("click", () => {
          switchTab(btn.dataset.tab);
        });
      });

      uploadBtn.addEventListener("click", async () => {
        const file = fileInput.files[0];
        if (!file) {
          setStatus("Please choose a PDF or DOCX file first.", true);
          return;
        }

        uploadBtn.disabled = true;
        acceptScope.checked = false;
        requirementsOutput.textContent = "Accept scoped text to reveal…";
        reqPill.classList.remove("pill-ok");
        
        updateAgentStatus("extraction", "processing", extractionPill, extractionStatus);
        updateAgentStatus("scope", "waiting", scopePill, scopeStatus);
        updateAgentStatus("requirements", "waiting", reqPill, reqStatus);
        extractionOutput.textContent = "Processing...";
        ocrOutput.textContent = "Waiting for OCR…";
        scopeOutput.textContent = "Waiting for extraction...";
        
        agentsSection.style.display = "block";
        setStatus("Uploading and running agents… this may take a moment.");

        try {
          const form = new FormData();
          form.append("file", file);

          const response = await fetch(`${API_BASE}/process-rfp`, {
            method: "POST",
            body: form,
          });

          if (!response.ok) {
            const text = await response.text();
            updateAgentStatus("extraction", "error", extractionPill, extractionStatus);
            throw new Error(
              `Backend error ${response.status}: ${text.slice(0, 200)}`,
            );
          }

          const data = await response.json();
          lastPipelineResult = data;

          if (data.ocr_source_text) {
            ocrOutput.textContent = data.ocr_source_text;
          } else {
            ocrOutput.textContent = "No OCR text returned.";
          }

          updateAgentStatus("extraction", "complete", extractionPill, extractionStatus);
          extractionOutput.textContent = formatExtractionOutput(data.extraction);
          const extSummary = `Language: ${data.extraction?.language || "unknown"}, CPV codes: ${data.extraction?.cpv_codes?.length || 0}, Other codes: ${data.extraction?.other_codes?.length || 0}`;
          document.getElementById("extraction-summary").innerHTML = `<strong>Status:</strong> Complete<br><strong>Summary:</strong> ${extSummary}`;

          updateAgentStatus("scope", "complete", scopePill, scopeStatus);
          scopeOutput.textContent = formatScopeOutput(data.scope);
          const scopeSummary = `Necessary: ${data.scope?.necessary_text?.length || 0} chars, Comparison: ${data.scope?.comparison_agreement !== undefined ? (data.scope.comparison_agreement ? 'Agreed' : 'Disagreed') : 'N/A'}`;
          document.getElementById("scope-summary").innerHTML = `<strong>Status:</strong> Complete<br><strong>Summary:</strong> ${scopeSummary}`;

          updateAgentStatus("requirements", "waiting", reqPill, reqStatus);
          document.getElementById("req-summary").innerHTML =
            "<strong>Status:</strong> Waiting for scope approval<br><strong>Summary:</strong> Run after you accept the scoped text.";

          setStatus("Extraction and scope finished. Review, then accept scope to run requirements.");

          switchTab("ocr");
        } catch (err) {
          console.error(err);
          setStatus(`Failed to process file: ${err.message}`, true);
          updateAgentStatus("extraction", "error", extractionPill, extractionStatus);
        } finally {
          uploadBtn.disabled = false;
        }
      });

      acceptScope.addEventListener("change", async () => {
        if (!lastPipelineResult) return;
        if (acceptScope.checked) {
          try {
            updateAgentStatus("requirements", "processing", reqPill, reqStatus);
            document.getElementById("req-summary").innerHTML =
              "<strong>Status:</strong> Processing<br><strong>Summary:</strong> Running requirements agent...";

            const response = await fetch(`${API_BASE}/run-requirements`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                essential_text: lastPipelineResult.scope?.cleaned_text || "",
              }),
            });

            if (!response.ok) {
              const text = await response.text();
              updateAgentStatus("requirements", "error", reqPill, reqStatus);
              throw new Error(
                `Requirements backend error ${response.status}: ${text.slice(
                  0,
                  200,
                )}`,
              );
            }

            const reqData = await response.json();
            lastPipelineResult.requirements = reqData;

            requirementsOutput.textContent = formatRequirementsOutput(reqData);
            const reqSummary = `Solution: ${reqData?.solution_requirements?.length || 0}, Response structure: ${reqData?.response_structure_requirements?.length || 0}`;
            document.getElementById("req-summary").innerHTML = `<strong>Status:</strong> Complete<br><strong>Summary:</strong> ${reqSummary}`;
            reqPill.classList.add("pill-ok");
            updateAgentStatus("requirements", "complete", reqPill, reqStatus);
          } catch (err) {
            console.error(err);
            requirementsOutput.textContent = `Failed to run requirements agent: ${err.message}`;
            updateAgentStatus("requirements", "error", reqPill, reqStatus);
          }
        } else {
          requirementsOutput.textContent = "Accept scoped text to reveal…";
          reqPill.classList.remove("pill-ok");
          updateAgentStatus("requirements", "waiting", reqPill, reqStatus);
          document.getElementById("req-summary").innerHTML =
            "<strong>Status:</strong> Waiting for scope approval<br><strong>Summary:</strong> Run after you accept the scoped text.";
        }
      });
    </script>
  </body>
  </html>


